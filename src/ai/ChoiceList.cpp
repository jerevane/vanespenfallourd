// Generated by dia2code
#ifndef AI__CHOICELIST__C
#define AI__CHOICELIST__C

#include "ChoiceList.h"
#include "state/State.h"
#include "instance/Fight.h"


namespace ai {


    ChoiceList::ChoiceList() {

    }

    ChoiceList::~ChoiceList() {

    }

    ChoiceList::ChoiceList(engine::Engine* engine) {
        allAction.clear();
        ennemyTarget.clear();
        allyTarget.clear();

        player = engine->getRules()->getTurnList().at(0);
        allAction = player->CanUse();

        for(unsigned long i=1; i<engine->getRules()->getTurnList().size();++i) {
            if (player->getIsCharacter() == !engine->getRules()->getTurnList()[i]->getIsCharacter()) {
                if(!engine->getRules()->getTurnList().at(i)->getIsDead()) ennemyTarget.push_back(engine->getRules()->getTurnList().at(i));
            }
            else allyTarget.push_back(engine->getRules()->getTurnList().at(i));
        }

    }

    std::multimap<int, state::Element *> ChoiceList::getRandomChoicePossibilities() {
        std::multimap<int,state::Element* > resultat;
        //resultat.clear();

        for(int i=0; i<allAction.size(); ++i) {
            switch (allAction[i]) {
                case 3:
                case 4:
                case 5:
                case 16:
                case 18:
                    for (unsigned long j = 0; j < allyTarget.size(); ++j) {
                        resultat.insert(std::make_pair(allAction[i], allyTarget.at(j)));
                    }
                    break;

                default:
                    for (unsigned long j = 0; j < ennemyTarget.size(); ++j) {
                        resultat.insert(std::make_pair(allAction[i], ennemyTarget.at(j)));
                    }
                    break;

            }
        }

        return resultat;
    }

    std::multimap<int, state::Element *> ChoiceList::getRandomGoodChoicePossibilities() {
        std::multimap<int, state::Element *> result = getRandomChoicePossibilities();
        std::vector<state::Element*> temp;
        std::multimap<int, state::Element *>::iterator iterator_temp ;

        for(auto iter=result.begin(); iter!=result.end(); ++iter){
            int j=0,k=1;
            temp.clear();
                // Construction du tableau des targets des actions
                for (auto it=result.equal_range(iter->first).first; it!=result.equal_range(iter->first).second; ++it){
                    auto blabla = it;
                    temp.push_back(blabla->second);
                }
                switch(iter->first){
                    case 0:
                    case 1:
                    case 2:
                    case 6:
                    case 7:
                        // Spell Offensif -> best choice = lower HP && lower magic resist
                        // Tri ordre croissant HP puis erase si magic resist >0.6
                        // S'il existe plus d'une possibilité erase les suivantes

                        while(j<temp.size()-1){
                            if(temp.at((unsigned long) j)->getHP() > temp.at((unsigned long) k)->getHP()){
                                std::swap(temp.at((unsigned long) j), temp.at((unsigned long) k));
                            }
                            ++k;
                            if(k==temp.size()){
                                ++j;
                                k=j+1;
                            }
                        }
                        for(int l=0; l<temp.size(); ++l){
                            if(temp.at((unsigned long) l)->getMagicResist() > 0.6){
                                // On cherche l'équivalent dans la multimap
                                iterator_temp = result.equal_range(iter->first).first;
                                while(iterator_temp->second != temp.at((unsigned long) l)) ++iterator_temp;
                                result.erase(iterator_temp);
                                temp.erase(temp.begin()+l);
                                --l;
                            }
                        }
                        // Attention, s'il n'existe plus de possibilité on supprime la key
                        if(temp.size()>=1){
                            while(temp.size()!=1){
                                // On cherche l'équivalent dans la multimap
                                iterator_temp = result.equal_range(iter->first).first;
                                while(iterator_temp->second != temp.at(1)) ++iterator_temp;
                                result.erase(iterator_temp);
                                temp.erase(temp.begin()+1);

                            }
                        }
                        else result.erase(iter);
                        break;

                        // Fin Spell Offensif

                        // Spell Defensif
                    case 3:
                    case 5:
                    case 8:
                    case 16:
                    case 18:
                        // Type Heal
                        // Best choice = target lower HP
                        // Keep only the lower

                        while(j<temp.size()-1){
                            if(temp.at((unsigned long) j)->getHP() > temp.at((unsigned long) k)->getHP()){
                                std::swap(temp.at((unsigned long) j), temp.at((unsigned long) k));
                            }
                            ++k;
                            if(k==temp.size()){
                                ++j;
                                k=j+1;
                            }
                        }
                        // Attention, s'il n'existe plus de possibilités on supprime la key
                        if(temp.size()>=1){
                            while(temp.size()!=1){
                                // On cherche l'équivalent dans la multimap
                                iterator_temp = result.equal_range(iter->first).first;
                                while(iterator_temp->second != temp.at(1)) ++iterator_temp;
                                result.erase(iterator_temp);
                                temp.erase(temp.begin()+1);

                            }
                        }
                        else result.erase(iter);
                        break;

                    case 4:
                    case 17:
                        // Type Rez
                        // Best choice = ally if he is dead
                        // Erase all other possibilities

                        for(int l=0; l<temp.size(); ++l){
                            if(!temp.at((unsigned long) l)->getIsDead()){
                                // On cherche l'équivalent dans la multimap
                                iterator_temp = result.equal_range(iter->first).first;
                                while(iterator_temp->second != temp.at((unsigned long) l)) ++iterator_temp;
                                result.erase(iterator_temp);
                                temp.erase(temp.begin()+l);
                                --l;
                            }
                        }
                        if(temp.size()>=1){
                            while(temp.size()!=1){
                                // On cherche l'équivalent dans la multimap
                                iterator_temp = result.equal_range(iter->first).first;
                                while(iterator_temp->second != temp.at(1)) ++iterator_temp;
                                result.erase(iter);
                                temp.erase(temp.begin()+1);

                            }
                        }
                        else result.erase(iter);
                        break;

                        // Fin Spell Defensif

                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        // Attack Offensif
                        // Best choice = lower HP && lower physic resist

                        while(j<temp.size()-1){
                            if(temp.at((unsigned long) j)->getHP() > temp.at((unsigned long) k)->getHP()){
                                std::swap(temp.at((unsigned long) j), temp.at((unsigned long) k));
                            }
                            ++k;
                            if(k==temp.size()){
                                ++j;
                                k=j+1;
                            }
                        }
                        for(int l=0; l<temp.size(); ++l){
                            if(temp.at((unsigned long) l)->getPhysResist() > 0.6){
                                // On cherche l'équivalent dans la multimap
                                iterator_temp= result.equal_range(iter->first).first;
                                while(iterator_temp->second != temp.at((unsigned long) l)) ++iterator_temp;
                                result.erase(iterator_temp);
                                temp.erase(temp.begin()+l);
                                --l;
                            }
                        }
                        // Attention, s'il n'existe plus de possibilité on supprime la key
                        if(temp.size()>=1){
                            while(temp.size()!=1){
                                // On cherche l'équivalent dans la multimap
                                iterator_temp = result.equal_range(iter->first).first;
                                while(iterator_temp->second != temp.at(1)) ++iterator_temp;
                                result.erase(iterator_temp);
                                temp.erase(temp.begin()+1);

                            }
                        }
                        else result.erase(iter);
                        break;

                        // Fin Attack Offensif

                    default:break;
                }
            }

        return result;
    }

    float ChoiceList::getWeightOnOneAction(std::multimap<int, state::Element *> action_target_map) {
        auto iter = action_target_map.begin();
        engine::Action *action = nullptr;
        float weight=0;
        state::Element* temp_target;
        state::Element* temp_player = player->clone();

        temp_target = iter->second->clone();
        switch(iter->first){
            case 0:
            case 1:
            case 2:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
                // Spell offensif
                if(iter->first == 15) action->Attack(temp_player,temp_target);
                else action->SpellCast(iter->first, temp_player, temp_target );

                 // Maintenant on peut pondérer suivant l'impact de l'action
                // Si l'ennemi est mort, le gain est très important
                if(temp_target->getIsDead()){
                    weight = 20;
                }
                    // S'il ne l'est pas on calcul le score en fonction des PV enlevés par rapport aux PVmax
                        // Ce score est diminué d'un malus pour le nombre de MP utilisé
                else {
                    // Formule : (PV_enlevé / PV_max)*20 (résultat entre 0 et 20)
                    weight = ((iter->second->getHP() - temp_target->getHP())/ temp_target->getMaxHP())*20;
                    weight = weight - ((player->getMP()-temp_player->getMP())/ temp_player->getMaxMP())*10;
                }
                break;

            case 3:
            case 5:
            case 16:
            case 18:
                // Spell / Item defensif de type Heal

                if(iter->first == (3|5|8)){
                    action->SpellCast(iter->first, temp_player, temp_target );
                }
                else action->UseItem(iter->first, temp_player,temp_target);

                // Maintenant on peut pondérer suivant l'impact de l'action
                // Calcul du score suivant le % de vie rendu
                // Bonus : -> si -10% de vie
                // Malus : -> MP consommé ou nombre d'objets restants du même type
                weight = ((temp_target->getHP() - iter->second->getHP())/temp_target->getMaxHP())*20;
                if(iter->second->getHP() <= 0.1*iter->second->getMaxHP()){
                    weight = weight + 10;
                }
                if(iter->first == (3|5|8)){
                    weight = weight - ((player->getMP()-temp_player->getMP())/ temp_player->getMaxMP())*10;
                }
                else weight = weight - (1/player->getItem()->getItem().find(iter->first)->second);
                break;

            case 4:
            case 17:
                // Spell / Item defensif de type Rez

                if(iter->first == 4){
                    action->SpellCast(iter->first, temp_player, temp_target );
                }
                else action->UseItem(iter->first, temp_player,temp_target);

                // Maintenant on peut pondérer suivant l'impact de l'action
                // Si la cible est morte alors le gain est maximum
                // Malus : -> MP consommé ou nombre d'objets restants du même type
                if(iter->second->getIsDead()){
                    weight = 20;
                    if(iter->first == 4){
                        weight = weight - ((player->getMP()-temp_player->getMP())/ temp_player->getMaxMP())*10;
                    }
                    else weight = weight - (1/player->getItem()->getItem().find(iter->first)->second);
                }
                else weight = 0;
                break;

            case 6:
            case 7:
            case 8:
            case 19:
                // Techniques à implementer
                weight = 0;
                break;

            default:break;
        }

        return weight;
    }

    float ChoiceList::getWeightMaxMin(std::map<int, float> list_action_weight, bool maxormin) {
        // Si minormax == true alors on prend le max sinon le min

        float result=0;

        for(auto iter =list_action_weight.begin(); iter!=list_action_weight.end(); ++iter){
            auto cacahuete = iter;
            if(result < cacahuete->second) result = cacahuete->second;
        }

        if(maxormin) return result;
        else return -result;
    }


};

#endif
