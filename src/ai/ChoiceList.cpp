// Generated by dia2code
#ifndef AI__CHOICELIST__C
#define AI__CHOICELIST__C

#include "ChoiceList.h"
#include "state/State.h"
#include "instance/Fight.h"


namespace ai {


    ChoiceList::ChoiceList() {

    }

    ChoiceList::~ChoiceList() {

    }

    ChoiceList::ChoiceList(engine::Engine* engine) {
        allAction.clear();
        ennemyTarget.clear();
        allyTarget.clear();

        player = engine->getRules()->getTurnList().at(0);
        allAction = player->CanUse();

        for(unsigned long i=1; i<engine->getRules()->getTurnList().size();++i) {
            if (player->getIsCharacter() == !engine->getRules()->getTurnList()[i]->getIsCharacter()) {
                ennemyTarget.push_back(engine->getRules()->getTurnList().at(i));
            }
            else allyTarget.push_back(engine->getRules()->getTurnList().at(i));
        }
    }

    std::multimap<int, state::Element *> ChoiceList::getRandomChoicePossibilities() {
        std::multimap<int,state::Element* > result;
        result.clear();

        for(int i=0; i<allAction.size(); ++i){
            if( i == 3|4|5|16|17|18 ){
                for(unsigned long j=0; j<allyTarget.size(); ++j){
                    result.insert(std::make_pair(i,allyTarget.at(j)));
                }
            }
            else{
                for(unsigned long j=0; j<ennemyTarget.size(); ++j){
                    result.insert(std::make_pair(i,ennemyTarget.at(j)));
                }
            }

        }

        return result;
    }

    std::multimap<int, state::Element *> ChoiceList::getRandomGoodChoicePossibilities() {
        std::multimap<int, state::Element *> result = getRandomChoicePossibilities();
        std::vector<state::Element*> temp;
        temp.clear();

        for(int i=0; i<19; ++i){
            int j=0,k=1,t=0;
            auto iter = result.find(i);
            if(iter != result.end()){
                // Construction du tableau des targets des actions
                for (auto it=result.equal_range(i).first; it!=result.equal_range(i).second; ++it){
                    temp.at((unsigned long) t) = it->second;
                    ++t;
                }
                switch(i){
                    case 0|1|2|6|7 :
                        // Spell Offensif -> best choice = lower HP && lower magic resist
                        // Tri ordre croissant HP puis erase si magic resist >0.6
                        // S'il existe plus d'une possibilité erase les suivantes

                        while(j<temp.size()-1){
                            if(temp.at((unsigned long) j)->getHP() > temp.at((unsigned long) k)->getHP()){
                                std::swap(temp.at((unsigned long) j), temp.at((unsigned long) k));
                            }
                            ++k;
                            if(k==temp.size()){
                                ++j;
                                k=j+1;
                            }
                        }
                        for(int l=0; l<temp.size(); ++l){
                            if(temp.at((unsigned long) l)->getMagicResist() > 0.6){
                                // On cherche l'équivalent dans la multimap
                                iter = result.equal_range(i).second;
                                while(iter->second != temp.at((unsigned long) l)) ++iter;
                                result.erase(iter);
                                temp.erase(temp.begin()+l);
                                --l;
                            }
                        }
                        // Attention, s'il n'existe plus de possibilité on supprime la key
                        if(temp.size()>=1){
                            while(temp.size()!=1){
                                // On cherche l'équivalent dans la multimap
                                iter = result.equal_range(i).second;
                                while(iter->second != temp.at(1)) ++iter;
                                result.erase(iter);
                                temp.erase(temp.begin()+1);

                            }
                        }
                        else result.erase(i);

                        // Fin Spell Offensif

                        // Spell Defensif
                    case 3|5|8|16|18 :
                        // Type Heal
                        // Best choice = target lower HP
                        // Keep only the lower

                        while(j<temp.size()-1){
                            if(temp.at((unsigned long) j)->getHP() > temp.at((unsigned long) k)->getHP()){
                                std::swap(temp.at((unsigned long) j), temp.at((unsigned long) k));
                            }
                            ++k;
                            if(k==temp.size()){
                                ++j;
                                k=j+1;
                            }
                        }
                        // Attention, s'il n'existe plus de possibilités on supprime la key
                        if(temp.size()>=1){
                            while(temp.size()!=1){
                                // On cherche l'équivalent dans la multimap
                                iter = result.equal_range(i).second;
                                while(iter->second != temp.at(1)) ++iter;
                                result.erase(iter);
                                temp.erase(temp.begin()+1);

                            }
                        }
                        else result.erase(i);

                    case 4|17 :
                        // Type Rez
                        // Best choice = ally if he is dead
                        // Erase all other possibilities

                        for(int l=0; l<temp.size(); ++l){
                            if(!temp.at((unsigned long) l)->getIsDead()){
                                // On cherche l'équivalent dans la multimap
                                iter = result.equal_range(i).second;
                                while(iter->second != temp.at((unsigned long) l)) ++iter;
                                result.erase(iter);
                                temp.erase(temp.begin()+l);
                                --l;
                            }
                        }
                        if(temp.size()>=1){
                            while(temp.size()!=1){
                                // On cherche l'équivalent dans la multimap
                                iter = result.equal_range(i).second;
                                while(iter->second != temp.at(1)) ++iter;
                                result.erase(iter);
                                temp.erase(temp.begin()+1);

                            }
                        }
                        else result.erase(i);

                        // Fin Spell Defensif

                    case 9|10|11|12|13|14 :
                        // Attack Offensif
                        // Best choice = lower HP && lower physic resist

                        while(j<temp.size()-1){
                            if(temp.at((unsigned long) j)->getHP() > temp.at((unsigned long) k)->getHP()){
                                std::swap(temp.at((unsigned long) j), temp.at((unsigned long) k));
                            }
                            ++k;
                            if(k==temp.size()){
                                ++j;
                                k=j+1;
                            }
                        }
                        for(int l=0; l<temp.size(); ++l){
                            if(temp.at((unsigned long) l)->getPhysResist() > 0.6){
                                // On cherche l'équivalent dans la multimap
                                iter = result.equal_range(i).second;
                                while(iter->second != temp.at((unsigned long) l)) ++iter;
                                result.erase(iter);
                                temp.erase(temp.begin()+l);
                                --l;
                            }
                        }
                        // Attention, s'il n'existe plus de possibilité on supprime la key
                        if(temp.size()>=1){
                            while(temp.size()!=1){
                                // On cherche l'équivalent dans la multimap
                                iter = result.equal_range(i).second;
                                while(iter->second != temp.at(1)) ++iter;
                                result.erase(iter);
                                temp.erase(temp.begin()+1);

                            }
                        }
                        else result.erase(i);

                        // Fin Attack Offensif

                    default:break;
                }
            }
        }

        return result;
    }

    float ChoiceList::getWeightOnOneAction(std::multimap<int, state::Element *> action_target_map) {
        auto iter = action_target_map.begin();
        engine::Action *action = nullptr;
        float weight=0;
        state::Element* temp_target;
        state::Element* temp_player = player->clone();

        temp_target = iter->second->clone();
        switch(iter->first){
            case 0|1|2|9|10|11|12|13|14|15 :
                // Spell offensif
                if(iter->first == 15) action->Attack(temp_player,temp_target);
                else action->SpellCast(iter->first, temp_player, temp_target );

                 // Maintenant on peut pondérer suivant l'impact de l'action
                // Si l'ennemi est mort, le gain est très important
                if(temp_target->getIsDead()){
                    weight = 20;
                }
                    // S'il ne l'est pas on calcul le score en fonction des PV enlevés par rapport aux PVmax
                        // Ce score est diminué d'un malus pour le nombre de MP utilisé
                else {
                    // Formule : (PV_enlevé / PV_max)*20 (résultat entre 0 et 20)
                    weight = ((iter->second->getHP() - temp_target->getHP())/ temp_target->getMaxHP())*20;
                    weight = weight - ((player->getMP()-temp_player->getMP())/ temp_player->getMaxMP())*10;
                }
                break;

            case 3|5|16|18 :
                // Spell / Item defensif de type Heal

                if(iter->first == 3|5|8){
                    action->SpellCast(iter->first, temp_player, temp_target );
                }
                else action->UseItem(iter->first, temp_player,temp_target);

                // Maintenant on peut pondérer suivant l'impact de l'action
                // Calcul du score suivant le % de vie rendu
                // Bonus : -> si -10% de vie
                // Malus : -> MP consommé ou nombre d'objets restants du même type
                weight = ((temp_target->getHP() - iter->second->getHP())/temp_target->getMaxHP())*20;
                if(iter->second->getHP() <= 0.1*iter->second->getMaxHP()){
                    weight = weight + 10;
                }
                if(iter->first == 3|5|8){
                    weight = weight - ((player->getMP()-temp_player->getMP())/ temp_player->getMaxMP())*10;
                }
                else weight = weight - (1/player->getItem()->getItem().find(iter->first)->second);
                break;

            case 4|17 :
                // Spell / Item defensif de type Rez

                if(iter->first == 4){
                    action->SpellCast(iter->first, temp_player, temp_target );
                }
                else action->UseItem(iter->first, temp_player,temp_target);

                // Maintenant on peut pondérer suivant l'impact de l'action
                // Si la cible est morte alors le gain est maximum
                // Malus : -> MP consommé ou nombre d'objets restants du même type
                if(iter->second->getIsDead()){
                    weight = 20;
                    if(iter->first == 4){
                        weight = weight - ((player->getMP()-temp_player->getMP())/ temp_player->getMaxMP())*10;
                    }
                    else weight = weight - (1/player->getItem()->getItem().find(iter->first)->second);
                }
                else weight = 0;
                break;

            case 6|7|8|19 :
                // Techniques à implementer
                weight = 0;
                break;

            default:break;
        }

        return weight;
    }

    float ChoiceList::getWeightMaxMin(std::map<int, float> list_action_weight, bool maxormin) {
        // Si minormax == true alors on prend le max sinon le min

        auto iter = list_action_weight.begin();
        float result=0;

        while(iter != list_action_weight.end()){
            if(result < iter->second) result = iter->second;
            iter = iter ++;
        }

        if(maxormin) return result;
        else return -result;
    }


};

#endif
