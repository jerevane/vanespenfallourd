// Generated by dia2code
#ifndef AI__SMARTCHOICE__C
#define AI__SMARTCHOICE__C

#include <iostream>
#include "SmartChoice.h"


namespace ai {


    SmartChoice::SmartChoice() {

    }

    SmartChoice::~SmartChoice() {

    }

    SmartChoice::SmartChoice(instance::Fight *fight, engine::Engine *engine) :AI(fight) {
        Id = 2;
        this->engine = engine;
    }

    void SmartChoice::run() {
        // L'innitialisation de minormax n'a pas d'importance
        bool minormax= false;

        int best_action=15; // Réglé de base sur une attaque normale
        float maxgain=0;

        std::multimap<int, state::Element*> choice = choiceList->getRandomGoodChoicePossibilities();
        std::map<int, float> temp = minmax(engine, minormax, 4);
        auto iter = temp.begin();
        while(iter != temp.end()){
            if(maxgain < iter->second){
                best_action = iter->first;
                maxgain = iter->second;
            }
        }
        std::cout << "\n AI level 3, gain max at this turn : " << best_action << "\n" << std::endl;
        if(maxgain <= 0){
            std::cout << "Ce joueur va perdre si son ennemi joue son meilleur coup !\n" << std::endl;
        }

        ChoiceAction = best_action;
        ChoiceTarget = choice.find(ChoiceAction)->second;

        setNotify(true);

    }

    std::map<int, float> SmartChoice::minmax(engine::Engine* engine, bool minormax, int step) {

        // On crée 2 lot de Rules -> la première va permettre de garder la Rules de départ
        //                        -> la suivante va permettre de travailler sur un state cloné

        engine::Rules* rules_temp = engine->getRules();

        state::State* state_temp = engine->getRules()->getState()->clone();

        engine::Rules* rules_new = new engine::Rules(state_temp, rules_temp->getAICharNeeded(),
                                                     rules_temp->getAIMonsterNeeded());
        engine->setRules(rules_new);

        // Création de la ChoiceList spécifique au player actuel
        ChoiceList* Listchoice = new ChoiceList(engine);
        std::multimap<int,state::Element*> choice = Listchoice->getRandomGoodChoicePossibilities();
        auto iter_choice = choice.begin();

        engine::Action *action = nullptr;
        bool notify =false;

        // Décision si on addition une valeur positive ou négative au poid total
        // -> addition si même équipe
        // -> soustraction si ennemi
        minormax = rules_new->getTurnList().at(0)->getIsCharacter() == rules_new->getTurnList().at(1)->getIsCharacter();

        std::map<int, float> result;
        result.clear();

        // On parcourt l'arbre des possibilités en remontant le gain max ou min des futurs joueurs
        while(iter_choice != choice.end()){
            // On installe les poids des actions possibles du dernier joueur envisagé, pas de changement d'état
            if(step == 0){
                result.insert(std::make_pair(iter_choice->first, Listchoice->getWeightOnOneAction(choice)));
            }
            else {
                // On applique l'état de l'action et on applique next_turn
                state::State* state_temp_after_apply = state_temp->clone();
                action->apply(state_temp_after_apply, rules_new->getTurnList().at(0), iter_choice->first,
                              iter_choice->second, notify);

                // On passe au tour suivant
                rules_new->NextTurn();

                // On insère dans le tableau résultat l'action et l'addition du poid de l'action et du MaxMin des autres
                // possibilités
                result.insert(std::make_pair(iter_choice->first, Listchoice->getWeightOnOneAction(choice) +
                                                                 Listchoice->getWeightMaxMin(
                                                                         minmax(engine, minormax, step - 1), minormax)));

                // On revient en arrière pour l'action suivante
                rules_new->PreviousTurn();
            }
        }

        // On remet les règles du départ
        engine->setRules(rules_temp);

        return result;
    }
};

#endif