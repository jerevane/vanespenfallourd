// Generated by dia2code
#ifndef ENGINE__ACTION__C
#define ENGINE__ACTION__C

#include <sstream>
#include "Action.h"



namespace engine {


    Action::Action() {

    }

    Action::~Action() {

    }

    void Action::apply(state::State *state, state::Element *caster, int action,
                       state::Element *target, bool notify) {
        if(action == 15){
            Attack(caster, target);
        }
        else if (action > 15){
            UseItem(action, caster, target);
        }
        else SpellCast(action, caster, target);
        notify = true;
    }

    void Action::SpellCast(int ability, state::Element *caster, state::Element *target) {
        std::string result;
        result = caster->getAbility()->LaunchAbility(ability, caster);
        TakeDamage(result,target);
    }

    void Action::Attack(state::Element *caster, state::Element *target) {
        std::string result = "P_";
        int dmg;
        dmg = caster->getStrength() *2;
        result = result + std::to_string(dmg) + "_X_-";
        TakeDamage(result, target);
    }

    void Action::TakeDamage(std::string damage, state::Element *target) {
        std::vector<std::string> tempArray;
        for (int i = 0; i < damage.size(); ++i)
        {
            if (damage[i] == '_') {
                damage[i] = ' ';
            }
        }

        std::stringstream ss(damage);
        std::string tempChar;
        while (ss >> tempChar) {
            tempArray.push_back(tempChar);
        }
        std::string typedmg = tempArray[0];
        std::string dmg = tempArray[1];
        std::string dot = tempArray[2];
        std::string isHeal =  tempArray[3];
        //std::string dot_target = target->getDot();
        //int dot_target_dmg = stoi(dot_target.substr(0,dot_target.find(delimiter)));
        //int dot_target_turn = stoi(dot_target.substr(1,dot_target.find(delimiter)));
        int temp = stoi(dmg);
        // Si Soin
        if(isHeal == "+"){
            Heal(temp, target);
        }
            // Sinon damage
        else{
            // Prise en charge resistance + dot
            if(typedmg == ("M")) {
                temp = temp - (int) (temp * target->getMagicResist());
            }
            else {
                temp = temp - (int) (temp * target->getPhysResist());
            }
            //temp = target->getHP() - temp - stoi(dot_target.substr(0,dot_target.find(delimiter)));
            temp = target->getHP() - temp;
            if(temp<=0){
                // Si mort alors reset dot et set IsDead
                target->setIsDead(true);
                target->setHP(0);
                target->setDot("0_0");
            }
            else {
                // Inflige les degats et prise en charge dot
                target->setHP(temp);
                // Si tech inflige dot
//                if (dot != "0") {
//                    target->setDot(dot + "4");
//                }
//                else{
//                    // Si dot enlÃ¨ve un tour au dot
////                    if(dot_target_turn !=0){
////                        dot_target_turn = dot_target_turn -1;
////                        target->setDot(std::to_string(dot_target_dmg)+std::to_string(dot_target_turn));
////                    }
////                    else target->setDot("0_0");
//                }
            }
        }
    }

    void Action::Heal(int heal, state::Element *target) {
        int hp_target = target->getHP();
        // Le heal prend effet uniquement si la target n'est pas morte
        if(!target->getIsDead()){
            if(hp_target+heal>= target->getMaxHP()){
                target->setHP(target->getMaxHP());
            }
            else target->setHP(hp_target+heal);
        }
    }

    void Action::exec() {
        apply(state, caster, action, target, true);
    }

    void Action::UseItem(int id_item, state::Element *caster, state::Element *target) {
        std::string result;
        result = caster->getItem()->UseItem(target,id_item);
        TakeDamage(result,target);
    }

    Action::Action(state::Element *caster, state::Element *target, int action) : caster(caster),
                                                                                 target(target),
                                                                                 action(action)
    {
    }
};

#endif