// Generated by dia2code
#ifndef STATE__ABILITY__C
#define STATE__ABILITY__C

#include "Ability.h"
#include "Element.h"

namespace state {

    std::string Ability::LaunchAbility(int ability, Element *caster) {
        // Impl√©menter un switch case dans cette fonction pour chaque tech
        switch(ability){
            case BRazier :
                return Brazier(caster);

            case POISON :
                return Poison(caster);

            case FLare :
                return Flare(caster);

            case FAstHeal :
                return FastHeal(caster);

            case REsurrection :
                return Resurrection(caster);

            case HAste :
                return Haste(caster);

            case DEfender :
                return Defender(caster);

            case COunterAttack :
                return CounterAttack(caster);

            case BAttleCries :
                return BattleCries(caster);

            case BLeeding :
                return Bleeding(caster);

            case TRipleAttack :
                return TripleAttack(caster);

            case DOubleUse :
                return DoubleUse(caster);

            case MUltipleArrow :
                return MultipleArrow(caster);

            case POisonArrow :
                return PoisonArrow(caster);

            case PIercingArrow :
                return PiercingArrow(caster);

            default:break;
        }
        return "error";
    }

    std::map<int, bool> Ability::getAbility() {
        return abilities;
    }

    void Ability::setAbility(int ability) {
        abilities[ability] = true;
    }

    void Ability::unsetAbility(int ability) {
        abilities[ability]=false;
    }

    std::string Ability::Brazier(Element* caster) {
        std::string result ="M_";
        int dmg = caster->getIntelligence()*10;
        result = result + std::to_string(dmg) + "_0_-";

        return result;
    }

    std::string Ability::Poison(Element* caster) {
        std::string result = "M_0_";
        int dmg = caster->getIntelligence()*10;
        result = result + std::to_string(dmg) + "_-";
        return result;
    }

    std::string Ability::Flare(Element* caster) {
        return std::__cxx11::string();
    }

    std::string Ability::FastHeal(Element* caster) {
        std::string result = "M_";
        int dmg = caster->getIntelligence()*20;
        result = result + std::to_string(dmg) + "_0_+";
        return result;
    }

    std::string Ability::Resurrection(Element* caster) {
        return std::__cxx11::string();
    }

    std::string Ability::Haste(Element* caster) {
        return std::__cxx11::string();
    }

    std::string Ability::Defender(Element* caster) {
        return std::__cxx11::string();
    }

    std::string Ability::CounterAttack(Element* caster) {
        return std::__cxx11::string();
    }

    std::string Ability::BattleCries(Element* caster) {
        return std::__cxx11::string();
    }

    std::string Ability::Bleeding(Element* caster) {
        return std::__cxx11::string();
    }

    std::string Ability::TripleAttack(Element* caster) {
        return std::__cxx11::string();
    }

    std::string Ability::DoubleUse(Element* caster) {
        return std::__cxx11::string();
    }

    std::string Ability::MultipleArrow(Element* caster) {
        return std::__cxx11::string();
    }

    std::string Ability::PoisonArrow(Element* caster) {
        return std::__cxx11::string();
    }

    std::string Ability::PiercingArrow(Element* caster) {
        return std::__cxx11::string();
    }

    Ability::Ability() {
        init();
    }

    void Ability::init() {
        for(int i=0;i<15;++i){
            abilities.insert(std::make_pair(i,false));
        }
    }


};

#endif
